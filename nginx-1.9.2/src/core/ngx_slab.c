
/*
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 */

#include <ngx_config.h>
#include <ngx_core.h>

/*
????Ö¸????4?Ä±???,??Ã´??Á½Î»Ò»??Îª0,??Ê±???Ç¿???????Ö¸???Äº?Á½Î»??????,???????Ã¿Õ¼?.
??nginx??slab??,????Ê¹??ngx_slab_page_s?á¹¹???Ðµ?Ö¸??pre?Äº?Á½Î»??????,????Ö¸Ê¾??pageÒ³????slot??????ngx_slab_exact_size?Ä¹?Ïµ.
??page???Öµ?slot??Ð¡??32Ê±??,pre?Äº?Á½Î»ÎªNGX_SLAB_SMALL.
??page???Öµ?slot??????32Ê±??,pre?Äº?Á½Î»ÎªNGX_SLAB_EXACT
??page???Öµ?slot????32??Ê±??,pre?Äº?Á½Î»ÎªNGX_SLAB_BIG
??pageÒ³?æ²»????slotÊ±??,????????Ò³?????????Ã»?,pre?Äº?Á½Î»ÎªNGX_SLAB_PAGE
*/
#define NGX_SLAB_PAGE_MASK   3
#define NGX_SLAB_PAGE        0
#define NGX_SLAB_BIG         1
#define NGX_SLAB_EXACT       2
#define NGX_SLAB_SMALL       3

#if (NGX_PTR_SIZE == 4)

#define NGX_SLAB_PAGE_FREE   0
//????????Á¬??????????page???????Ò²?????page??????Ò»?Î·???3??page,??????pageÎª[1-3]????page[1].slab=3  page[2].slab=page[3].slab=NGX_SLAB_PAGE_BUSY??Â¼
#define NGX_SLAB_PAGE_BUSY   0xffffffff
#define NGX_SLAB_PAGE_START  0x80000000

#define NGX_SLAB_SHIFT_MASK  0x0000000f
#define NGX_SLAB_MAP_MASK    0xffff0000
#define NGX_SLAB_MAP_SHIFT   16

#define NGX_SLAB_BUSY        0xffffffff

#else /* (NGX_PTR_SIZE == 8) */

#define NGX_SLAB_PAGE_FREE   0
#define NGX_SLAB_PAGE_BUSY   0xffffffffffffffff
#define NGX_SLAB_PAGE_START  0x8000000000000000

#define NGX_SLAB_SHIFT_MASK  0x000000000000000f
#define NGX_SLAB_MAP_MASK    0xffffffff00000000
#define NGX_SLAB_MAP_SHIFT   32

#define NGX_SLAB_BUSY        0xffffffffffffffff

#endif


#if (NGX_DEBUG_MALLOC)

#define ngx_slab_junk(p, size)     ngx_memset(p, 0xA5, size)

#elif (NGX_HAVE_DEBUG_MALLOC)

#define ngx_slab_junk(p, size)                                                \
    if (ngx_debug_malloc)          ngx_memset(p, 0xA5, size)

#else

#define ngx_slab_junk(p, size)

#endif

static ngx_slab_page_t *ngx_slab_alloc_pages(ngx_slab_pool_t *pool,
    ngx_uint_t pages);
static void ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
    ngx_uint_t pages);
static void ngx_slab_error(ngx_slab_pool_t *pool, ngx_uint_t level,
    char *text);

//slabÒ³???Ä´?Ð¡,32Î»Linux??Îª4k,  
static ngx_uint_t  ngx_slab_max_size;//????ngx_slab_max_size = 2048B??????Ò»??Ò³Òª???Å¶???obj????obj sizeÒªÐ¡????????Öµ 
/*
????Ö¸????4?Ä±???,??Ã´??Á½Î»Ò»??Îª0,??Ê±???Ç¿???????Ö¸???Äº?Á½Î»??????,???????Ã¿Õ¼?.
??nginx??slab??,????Ê¹??ngx_slab_page_s?á¹¹???Ðµ?Ö¸??pre?Äº?Á½Î»??????,????Ö¸Ê¾??pageÒ³????slot??????ngx_slab_exact_size?Ä¹?Ïµ.
??page???Öµ?slot??Ð¡??32Ê±??,pre?Äº?Á½Î»ÎªNGX_SLAB_SMALL.
??page???Öµ?slot??????32Ê±??,pre?Äº?Á½Î»ÎªNGX_SLAB_EXACT
??page???Öµ?slot????32??Ê±??,pre?Äº?Á½Î»ÎªNGX_SLAB_BIG
??pageÒ³?æ²»????slotÊ±??,????????Ò³?????????Ã»?,pre?Äº?Á½Î»ÎªNGX_SLAB_PAGE
*/ //????32??slot??,Ã¿??slot?Ä´?Ð¡????ngx_slab_exact_size  
static ngx_uint_t  ngx_slab_exact_size;//????ngx_slab_exact_size = 128B???Ö½??Ç·?Òª?Ú»??????????????Õ¼???bitmap  
static ngx_uint_t  ngx_slab_exact_shift;//ngx_slab_exact_shift = 7????128??Î»??Ê¾ //Ã¿??slot????Ð¡??Î»????ngx_slab_exact_shift  

/*
×¢?â£¬??ngx_slab_pool_t??????Á½?????Íµ?slab page????È»????ngx_slab_page_t?????Ä½á¹¹?????Ç¹??Ü²?????Í¬??Ò»????slots????À´??Ê¾??
?Å½?Ð¡obj???Ú´???(????Ò³??Ð¡?? 4096B??????<2048B??obj????Ð¡??1/2Ò³)????Ò»??À´??Ê¾??Òª?????Ä¿Õ¼??Ú»???????Î»?Ã¡?Nginx?Ñ»???obj??
?É´??? (>=2048B)??Ð¡??(<2048B)??Ã¿?Î¸?????obj????Ò»????Ò³?????Ñ¶???Ð¡obj??????Ò»??Ò³?Ð¼ä£¬??bitmap?È·???À´??Ê¾ ??Õ¼?????ö¡£¶?Ð¡
??obj?Ö·?Îª3?Ö£?Ð¡??128B??????128B??????128B??Ð¡??2048B??????Ð¡??128B??obj??Òª??Êµ?Ê»????????????? bitmap?Õ¼?À´??Ê¾?Ú´?Ê¹??????
(??Îªslab??Ô±Ö»??4??byte??32bit??Ò»?ö»º´?Ò³4KB???Ô´??Åµ?obj????32???????Ô²?????slab À´??Ê¾)????????????Ò»???Ä¿Õ¼???Ê§?????Ú»???
??128B??obj??Îª??????Ò»??32bit??????À´??Ê¾??×´Ì¬?????Ô¾Í¿???Ö±????slab??Ô±??Ã¿?Î·??? ?Ä¿Õ¼???2^n????Ð¡??8byte??8??16??32??64??
128??256??512??1024??2048??Ð¡??2^i?Ò´???2^(i-1)??obj?á±»?? ??Ò»??2^i?Ä¿Õ¼ä£¬????56byte??obj?Í»?????Ò»??64byte?Ä¿Õ¼ä¡£
*/ //http://adam281412.blog.163.com/blog/static/33700067201111283235134/
/*
?????Ú´?????Êµ??Ö·??Ê¼??????:ngx_slab_pool_t + 9 * sizeof(ngx_slab_page_t)(slots_m[]) + pages * sizeof(ngx_slab_page_t)(pages_m[]) +pages*ngx_pagesize(????Êµ?Êµ????Ý²??Ö£?
Ã¿??ngx_pagesize????Ç°????Ò»??ngx_slab_page_t???Ð¹??í£¬????Ã¿??ngx_pagesize??Ç°?Ëµ?Ò»??obj???Åµ???Ò»?????ß¶???int????bitmap?????Ú¹???Ã¿????????È¥???Ú´?)
*/

    //Í¼?Î»??????Î¿?:http://blog.csdn.net/u013009575/article/details/17743261
void
ngx_slab_init(ngx_slab_pool_t *pool)//poolÖ¸???????????????Ú´??Õ¼?????Ê¼??Ö·   slab?á¹¹?????Ï¹????Ú´?Ê¹?Ãµ? ??????limit reqÄ£??Îª?????Î¿?ngx_http_limit_req_module
{
    u_char           *p;
    size_t            size;
    ngx_int_t         m;
    ngx_uint_t        i, n, pages;
    ngx_slab_page_t  *slots;

    /*
     //????Ã¿??page??4KB  
    //????ngx_slab_max_size = 2048B??????Ò»??Ò³Òª???Å¶???obj????obj sizeÒªÐ¡????????Öµ  
    //????ngx_slab_exact_size = 128B???Ö½??Ç·?Òª?Ú»??????????????Õ¼???bitmap  
    //ngx_slab_exact_shift = 7????128??Î»??Ê¾  
     */
    /* STUB */
    if (ngx_slab_max_size == 0) {
        ngx_slab_max_size = ngx_pagesize / 2;
        ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));
        for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) {
            /* void */
        }
    }
    /**/

    pool->min_size = 1 << pool->min_shift; //??Ð¡?????Ä¿Õ¼???8byte  

    p = (u_char *) pool + sizeof(ngx_slab_pool_t); //?????Ú´?Ç°????sizeof(ngx_slab_pool_t)?Ç¸?slab poll??
    size = pool->end - p; //size???ÜµÄ¹????Ú´? - sizeof(ngx_slab_pool_t)?Ö½Úº??Ä³???

    ngx_slab_junk(p, size);

    slots = (ngx_slab_page_t *) p;
    n = ngx_pagesize_shift - pool->min_shift;//12-3=9

/*
??Ð©slab page?Ç¸???Ð¡Îª8??16??32??64??128??256??512??1024??2048byte???Ú´??? ??Ð©slab page??Î»??????pool->pages??Ç°????Ê¼??  
?????Ú´?????Êµ??Ö·??Ê¼??????:ngx_slab_pool_t + 9 * sizeof(ngx_slab_page_t)(slots_m[]) + pages * sizeof(ngx_slab_page_t)(pages_m[]) +pages*ngx_pagesize(????Êµ?Êµ????Ý²??Ö£?
Ã¿??ngx_pagesize????Ç°????Ò»??ngx_slab_page_t???Ð¹??í£¬????Ã¿??ngx_pagesize??Ç°?Ëµ?Ò»??obj???Åµ???Ò»?????ß¶???int????bitmap?????Ú¹???Ã¿????????È¥???Ú´?)
*/
    for (i = 0; i < n; i++) { //??9??slots[]??9 * sizeof(ngx_slab_page_t)Ö¸??
        slots[i].slab = 0;
        slots[i].next = &slots[i];
        slots[i].prev = 0;
    }

    p += n * sizeof(ngx_slab_page_t); //??????????Ð©slab page  

    //**?????????Õ¼??Ü¹????Ô·????Ä»???Ò³(4KB)????Á¿??Ã¿??Ò³??overhead??Ò»??slab page?Ä´?Ð¡  
    //**??????overhead??????À¨Ö®????<128B??????????bitmap??????  

    //???? + sizeof(ngx_slab_page_t)??Ô­????Ã¿??ngx_pagesize???Ð¶?Ó¦??ngx_slab_page_t???Ð¹???
    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t))); //??????size?Ç²???Ó¦?Ã°?Í·??n * sizeof(ngx_slab_page_t)??È¥??????????????×¼È·?
    //??Ã¿?ö»º´?Ò³??Ç°????sizeof(ngx_slab_page_t)?Ö½Ú¶?Ó¦??slab page??0  
    ngx_memzero(p, pages * sizeof(ngx_slab_page_t));

    pool->pages = (ngx_slab_page_t *) p;

    //??Ê¼??free??free.next???Â´Î·???Ò³Ê±????????  
    pool->free.prev = 0;
    pool->free.next = (ngx_slab_page_t *) p;

    //???Âµ?Ò»??slab page??×´Ì¬??????slab??Ô±??Â¼?????ö»º´?????Ò³??Ä¿  
    pool->pages->slab = pages; //??Ò»??pages->slabÖ¸???Ë¹????Ú´??Ð³?È¥Í·????Ê£??Ò³?Ä¸???
    pool->pages->next = &pool->free;
    pool->pages->prev = (uintptr_t) &pool->free;

    //Êµ?Ê»?????(Ò³)?Ä¿?Í·??????   //??Îª??????Ô­??,Ê¹??m_page??????????????Ö®????????Ð©?Ú´??Þ·?Ê¹??,  
    pool->start = (u_char *)
                  ngx_align_ptr((uintptr_t) p + pages * sizeof(ngx_slab_page_t),
                                 ngx_pagesize);

    //????Êµ?Ê»??????Ä¿?Ê¼?Í½?Î²?Ù´Î¸????Ú´?Ò³????Ä¿  
    //?????Ú´?????????(pool->start???Ú´?????),???Üµ???pages????,  
    //????Òª????.mÎª??????pageÒ³???Ä¼?Ð¡Á¿.  
    //??Êµ???æ¼¸?Ð´??????àµ±??:  
    // pages =(pool->end - pool->start) / ngx_pagesize  
    //pool->pages->slab = pages;  
    m = pages - (pool->end - pool->start) / ngx_pagesize;
    if (m > 0) {
        pages -= m;
        pool->pages->slab = pages;
    }

    //????pages * sizeof(ngx_slab_page_t)??Ò²????Ö¸??Êµ?Êµ?????Ò³pages*ngx_pagesize
    pool->last = pool->pages + pages;

    pool->log_nomem = 1;
    pool->log_ctx = &pool->zero;
    pool->zero = '\0';
}

//?????Ç¹????Ú´æ£¬?????Ú½??Ì¼???Òª????À´????Í¬??
void *
ngx_slab_alloc(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    ngx_shmtx_lock(&pool->mutex);

    p = ngx_slab_alloc_locked(pool, size);

    ngx_shmtx_unlock(&pool->mutex);

    return p;
}

/*
???Ú¸???size,??slab_pool?Ð·????Ú´?.
1.????size???Úµ???Ò»Ò³,??Ã´??m_page?Ð²???,????????Ö±?Ó·???,????Ê§??.
2.????sizeÐ¡??Ò»Ò³,????Á´?????Ð¿???slot??.
     (1).????size????ngx_slab_exact_size,
a.????slab?Ä¸?16Î»(32Î»ÏµÍ³)????solt??Ó¦??map,???Ò¸Ã¶?Ó¦Îªmap?Äµ?Î»??Ó¦page?Ð¸?Î»??slot??.????1110??Ó¦Îª??1??slot?Ç¿??Ãµ?,2-4?é²»????.slab?Äµ?16Îª?æ´¢slot????Ð¡??Î»??.
b.????m_pageÔª?Øµ?preÖ¸??ÎªNGX_SLAB_BIG.
c.????page??È«??slot????Ê¹????,??Ã´????Ò³????m_slot????Ôª?Øµ?Á´?????Æ³?.
   (2).????size????ngx_slab_exact_size
a.????slab?æ´¢slot??map,Í¬??slab?ÐµÄµ?Î»??Ó¦??Î»?Ãµ?slot.
b.????m_pageÔª?Øµ?preÖ¸??ÎªNGX_SLAB_EXACT.
c.????page??È«??slot????Ê¹????,??Ã´????Ò³????m_slot????Ôª?Øµ?Á´?????Æ³?.
   (3).????sizeÐ¡??ngx_slab_exact_size
a.??page?Ðµ?Ç°????slot????slot??map,Í¬????Î»??Ó¦??Î».
b.????m_pageÔª?Øµ?preÖ¸??ÎªNGX_SLAB_SMALL.
b.????page??È«??slot????Ê¹????,??Ã´????Ò³????m_slot????Ôª?Øµ?Á´?????Æ³?.
 3.????Á´????Ã»?Ð¿?????slot??,????freeÁ´?????Òµ?Ò»?????Ðµ?Ò³????????m_slot????Ôª???Ðµ?Á´??.
   (1).????size????ngx_slab_exact_size,
a.????slab?Ä¸?16Î»(32Î»ÏµÍ³)????solt??Ó¦??map,???Ò¸Ã¶?Ó¦Îªmap?Äµ?Î»??Ó¦page?Ð¸?Î»??slot??.slab?Äµ?16Îª?æ´¢slot????Ð¡??Î»??.
b.????m_pageÔª?Øµ?preÖ¸??ÎªNGX_SLAB_BIG.
c.????????Ò³??Á´??m_slot????Ôª?Øµ?Á´????.
   (2).????size????ngx_slab_exact_size
a.????slab?æ´¢slot??map,Í¬??slab?ÐµÄµ?Î»??Ó¦??Î»?Ãµ?slot.
b.????m_pageÔª?Øµ?preÖ¸??ÎªNGX_SLAB_EXACT.
c.????????Ò³??Á´??m_slot????Ôª?Øµ?Á´????.
   (3).????sizeÐ¡??ngx_slab_exact_size
a.??page?Ðµ?Ç°????slot????slot??map,Í¬????Î»??Ó¦??Î».
b.????m_pageÔª?Øµ?preÖ¸??ÎªNGX_SLAB_SMALL.
c.????????Ò³??Á´??m_slot????Ôª?Øµ?Á´????.
4.?É¹??ò·µ»Ø·??????Ú´???,??Ö¸??p,????Ê§??,????null.

*/
//Í¼?Î»??????Î¿?:http://blog.csdn.net/u013009575/article/details/17743261
//???Øµ?Öµ????Òª?????Ä¿Õ¼????Ú´æ»º??????Î»??  

/*
??Ò»??pageÒ³?Ð»?È¡Ð¡??2048??obj????Ê±?ò£¬¶???????page->next = &slots[slot]; page->prev = &slots[slot]??slots[slot].next = page;Ò²??????Îªobj????Ò³
page[]?????Í¶?Ó¦??slots[]??Áª???????Ç·???????2048?Ä¿Õ¼ä£¬????????????Ò³????page[]??slots??Ã»?Ð¹?Ïµ
????pageÒ³???????????????Â°?page[]??next??prev??ÎªNULL??Í¬Ê±?Ñ¶?Ó¦??slot[]??next??prevÖ¸??slot[]????
??page???????Í·?????Ò»??obj?????Ð»Ö¸?Îªpage->next = &slots[slot]; page->prev = &slots[slot]??slots[slot].next = page;
*/
void * 
ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)
{ //????????page_size??4KB  
    size_t            s;
    uintptr_t         p, n, m, mask, *bitmap;
    ngx_uint_t        i, slot, shift, map;
    ngx_slab_page_t  *page, *prev, *slots;

    if (size > ngx_slab_max_size) { //??????large obj, size >= 2048B  

        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0,
                       "slab alloc: %uz", size);

        //????1?????????Ú´?Ò³  
        page = ngx_slab_alloc_pages(pool, (size >> ngx_pagesize_shift)
                                          + ((size % ngx_pagesize) ? 1 : 0)); //????size?Õº???4K,??page=1,??????4K+1????page=2
        if (page) {
            //????page??????page[0]??Æ«??Á¿????m_page??page???????à»¥??Ó¦??,??m_page[0]????page[0]Ò³??,m_page[1]????page[1]Ò³??.  
            //???Ô»???page??????m_page[0]??Æ«??Á¿?Í¿??Ô¸???start?Ãµ???Ó¦Ò³????Æ«??Á¿.  
            p = (page - pool->pages) << ngx_pagesize_shift;
            p += (uintptr_t) pool->start; //?Ãµ?Êµ?Ê·?????Ò³????Ê¼??Ö·

        } else {
            p = 0;
        }

        goto done;
    }

    //??Ð¡??obj, size < 2048B??????Òª??????sizeÀ´È·????slots??Î»?Ã£?Ã¿??slot????Ò»?Ö´?Ð¡??obj?Ä¼??Ï£???slots[0]??Ê¾8byte?Ä¿Õ¼ä£¬
    //slots[3]??Ê¾64byte?Ä¿Õ¼?????obj??Ð¡(<1B)??slot??Î»????1B?Õ¼???Î»?Ã£?????Ð¡????1B  
    if (size > pool->min_size) { //????Ê¹???Ä¸?slots[]??Ò²??????Òª?????Ä¿Õ¼??Ç¶???  ????size=9,????Ê¹??slot[1]??Ò²????16?Ö½?
        shift = 1;
        for (s = size - 1; s >>= 1; shift++) { /* void */ }
        slot = shift - pool->min_shift;

    } else {
        size = pool->min_size;
        shift = pool->min_shift;
        slot = 0;
    }

    //ngx_slab_pool_t + 9 * sizeof(ngx_slab_page_t) + pages * sizeof(ngx_slab_page_t) +pages*ngx_pagesize(????Êµ?Êµ????Ý²???)
    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0,
                   "slab alloc: %uz slot: %ui", size, slot);
                   
    //Ö¸??9 * sizeof(ngx_slab_page_t) ??Ò²????slots[0-8]???? = 8 - 2048
    slots = (ngx_slab_page_t *) ((u_char *) pool + sizeof(ngx_slab_pool_t));
    //??ngx_slab_init??slots[]->nextÄ¬????Ö¸???Ô¼???
    page = slots[slot].next;//????m_slot[slot]??????Ó¦??m_pageÔª??,È»???Òµ???Ó¦Ò³??.  

    if (page->next != page) { //????Ö®Ç°?Ñ¾??Ð´?????Ð¡obj???Ç¸??Ñ¾????????Ú´æ»º??Ò³??Î´??  9 ??ngx_slab_page_t????Ã»??????

        if (shift < ngx_slab_exact_shift) { //Ð¡obj??size < 128B???????Ú´æ»º??Ò³?Ðµ?bitmap???????Ø´??????Ä¿Õ¼??Ú»?????Î»??  

            do {
                p = (page - pool->pages) << ngx_pagesize_shift; 
                bitmap = (uintptr_t *) (pool->start + p);//pool->start??Ê¼??128?Ö½?Îª??Òª?????Ä¿Õ¼ä£¬????????Ò»??int 4?Ö½Ú¿Õ¼?????bitmap

                /*  
               ????Òª??????sizeÎª54?Ö½Ú£?????Ç°??????????shift??Ó¦???Ö½???Ó¦????64?Ö½Ú£?????Ò»??Ò³??È«??64?Ö½?obj??Ð¡??????Ò»????64
               ??64?Ö½Úµ?obj??64??obj??????Òª64Î»À´??Ê¾Ã¿??obj?Ç·???Ê¹?Ã£???????????Òª64Î»(Ò²????8?Ö½Ú£?2??int),????????Òª????Ò»??64
               ?Ö½?objÀ´?æ´¢??bitmap??Ï¢????Ò»??64?Ö½?objÊµ????Ö»????8?Ö½Ú£?????56?Ö½?Î´??
               */
                //??????Òª???Ù¸??Ö½?À´?æ´¢bitmap  
                map = (1 << (ngx_pagesize_shift - shift))
                          / (sizeof(uintptr_t) * 8);

                for (n = 0; n < map; n++) {

                    if (bitmap[n] != NGX_SLAB_BUSY) {//????page??obj??????,Ò²????bitmapÖ¸????32??obj?Ç·????Ñ¾?????????È¥??  
                        //????????pageÒ³??????slab?Ñ¾????ê£¬?????Úº?????ngx_slab_alloc_pages???Â»?È¡?Õ¼ä²¢????slab??È»??????
                        for (m = 1, i = 0; m; m <<= 1, i++) {//????obj?é±»Õ¼??,????????  ????32??obj???Ò³???Ò»??Î´????????È¥??obj
                            if ((bitmap[n] & m)) {
                                continue;
                            }

                            //?Òµ??Ë£???bitmap??Ó¦?Äµ?n??(×¢????Î»?Æ²???????m)Î´Ê¹?Ã£?Ê¹??????Í¬Ê±??Î»??Î»????Ê¾??bitmp[n]?Ñ¾??????Ù±????ä£¬??Îª?Ñ¾????Î·?????È¥??
                            bitmap[n] |= m;

                            i = ((n * sizeof(uintptr_t) * 8) << shift)
                                + (i << shift); //n*sizeof(uintptr_t)*8è®¡ç®—å‡ºé‚£äº›å…¨ä¸º1çš„bitmap[?]åŠ èµ·æ¥æ€»å…±æœ‰å¤šå°‘ä½ï¼Œè€Œæ¯ä¸ªä½å ç”¨ä¸€ä¸ªchunkï¼Œå†<<shiftï¼Œå³å¾—åˆ°è¿™äº›å ç”¨çš„chunkæ‰€å­—èŠ‚æ•°ã€‚i<<shiftä¸­çš„iæ˜¯æœ€åŽä¸€ä¸ªbitmap[n]ä¸­å·²è¢«ä½¿ç”¨çš„chunkæ•°é‡ï¼Œi<<shiftæ˜¯å¯¹åº”å­—èŠ‚æ•°

                            if (bitmap[n] == NGX_SLAB_BUSY) { //??????32Î»Í¼??????È¡????????31Î»(0-31)??Ê±????Ç°????bitmap[n] |= m??;Ê¹???Õº?NGX_SLAB_BUSY??Ò²????Î»Í¼????
                                for (n = n + 1; n < map; n++) {
                                     if (bitmap[n] != NGX_SLAB_BUSY) {//??????bitmap?????Ä¼???bitmap??Ã»?????ê£¬??Ö±?Ó·??Ø¸?bitmap??Ö·
                                         p = (uintptr_t) bitmap + i;

                                         goto done;
                                     }
                                }
                                //& ~NGX_SLAB_PAGE_MASK??????Ô­??????Òª?Ö¸?Ô­À´?Äµ?Ö·????Îª??Á½Î»?Úµ?Ò»?Î»?È¡?Õ¼???Ê±???????????????å´¦??
                                prev = (ngx_slab_page_t *)
                                            (page->prev & ~NGX_SLAB_PAGE_MASK); //Ò²???Ç¸?obj??Ó¦??slot_m[]

                                //pages_m[i]??slot_m[i]È¡????Ó¦?????Ã¹?Ïµ????Îª??pages_m[i]Ö¸????Ò³page?Ñ¾???????
                                prev->next = page->next;
                                page->next->prev = page->prev; //slot_m[i]?á¹¹??next??prevÖ¸???Ô¼?

                                page->next = NULL; //page??next??prevÖ¸??NULL????Ê¾???Ù¿???À´????slot[]??Ó¦??obj
                                page->prev = NGX_SLAB_SMALL;
                            }

                            p = (uintptr_t) bitmap + i;

                            goto done;
                        }
                    }
                }

                page = page->next;

            } while (page);

        } else if (shift == ngx_slab_exact_shift) {
            //size == 128B????ÎªÒ»??Ò³???Ô·?32??????slab page??slab??Ô±À´??×¢Ã¿???Ú´???Õ¼?????ö£¬²???Òª???????Ú´æ»º????????bitmap??
            //?????Ø´??????Ä¿Õ¼??Ú»?????Î»??  

            do {
                if (page->slab != NGX_SLAB_BUSY) { //??page?Ç·??Ñ¾?????

                    for (m = 1, i = 0; m; m <<= 1, i++) { //????????pageÒ³??????slab?Ñ¾????ê£¬?????Úº?????ngx_slab_alloc_pages???Â»?È¡?Õ¼ä²¢????slab??È»??????
                        if ((page->slab & m)) {
                            continue;
                        }

                        page->slab |= m; //???Çµ?m??slab???Ú·?????È¥??

                        if (page->slab == NGX_SLAB_BUSY) {//Ö´????page->slab |= m;?????Ð¿???page->slab == NGX_SLAB_BUSY????Ê¾????Ò»??obj?Ñ¾???????È¥??
                            //pages_m[i]??slot_m[i]È¡????Ó¦?????Ã¹?Ïµ????Îª??pages_m[i]Ö¸????Ò³page?Ñ¾???????
                            prev = (ngx_slab_page_t *)
                                            (page->prev & ~NGX_SLAB_PAGE_MASK);
                            prev->next = page->next;
                            page->next->prev = page->prev;

                            page->next = NULL;
                            page->prev = NGX_SLAB_EXACT;
                        }

                        p = (page - pool->pages) << ngx_pagesize_shift;
                        p += i << shift;
                        p += (uintptr_t) pool->start; //???Ø¸?obj??Ó¦?Äµ?Ö·

                        goto done; 
                    }
                }

                page = page->next;

            } while (page);

        } else { /* shift > ngx_slab_exact_shift */

   //size > 128B??Ò²?Ç¸???slab page??slab??Ô±????????ÒªÔ¤??????slab?Ä²???bit????ÎªÒ»??Ò³??obj??Á¿Ð¡??32?ö£¬²????Ø´??????Ä¿Õ¼??Ú»?????Î»??  
            n = ngx_pagesize_shift - (page->slab & NGX_SLAB_SHIFT_MASK);
            n = 1 << n;
            n = ((uintptr_t) 1 << n) - 1;
            mask = n << NGX_SLAB_MAP_SHIFT;

            do {//????????pageÒ³??????slab?Ñ¾????ê£¬?????Úº?????ngx_slab_alloc_pages???Â»?È¡?Õ¼ä²¢????slab??È»??????
                if ((page->slab & NGX_SLAB_MAP_MASK) != mask) {

                    for (m = (uintptr_t) 1 << NGX_SLAB_MAP_SHIFT, i = 0;
                         m & mask;
                         m <<= 1, i++)
                    {
                        if ((page->slab & m)) {
                            continue;
                        }

                        page->slab |= m;

                        if ((page->slab & NGX_SLAB_MAP_MASK) == mask) {
                            prev = (ngx_slab_page_t *)
                                            (page->prev & ~NGX_SLAB_PAGE_MASK);
                            prev->next = page->next;
                            page->next->prev = page->prev;

                            page->next = NULL;
                            page->prev = NGX_SLAB_BIG;
                        }

                        p = (page - pool->pages) << ngx_pagesize_shift;
                        p += i << shift;
                        p += (uintptr_t) pool->start;

                        goto done;
                    }
                }

                page = page->next;

            } while (page);
        }
    }

    //?Ö³?Ò»Ò³???ëµ½m_slot??????Ó¦Ôª????  
    page = ngx_slab_alloc_pages(pool, 1);

    /*  
       ????Òª??????sizeÎª54?Ö½Ú£?????Ç°??????????shift??Ó¦???Ö½???Ó¦????64?Ö½Ú£?????Ò»??Ò³??È«??64?Ö½?obj??Ð¡??????Ò»????64
       ??64?Ö½Úµ?obj??64??obj??????Òª64Î»À´??Ê¾Ã¿??obj?Ç·???Ê¹?Ã£???????????Òª64Î»(Ò²????8?Ö½Ú£?2??int),????????Òª????Ò»??64
       ?Ö½?objÀ´?æ´¢??bitmap??Ï¢????Ò»??64?Ö½?objÊµ????Ö»????8?Ö½Ú£?????56?Ö½?Î´??
     */
    if (page) {
        //size<128
        if (shift < ngx_slab_exact_shift) {
            p = (page - pool->pages) << ngx_pagesize_shift;//slot????map?æ´¢??page??slot?Ð¶?Î»????Ó¦??page  
            bitmap = (uintptr_t *) (pool->start + p); //pageÒ³????Ê¼??Ö·??Ò»??uintptr_t????4?Ö½???À´?æ´¢bitmap??Ï¢

            /*  
               ????Òª??????sizeÎª54?Ö½Ú£?????Ç°??????????shift??Ó¦???Ö½???Ó¦????64?Ö½Ú£?????Ò»??Ò³??È«??64?Ö½?obj??Ð¡??????Ò»????64
               ??64?Ö½Úµ?obj??64??obj??????Òª64Î»À´??Ê¾Ã¿??obj?Ç·???Ê¹?Ã£???????????Òª64Î»(Ò²????8?Ö½Ú£?2??int),????????Òª????Ò»??64
               ?Ö½?objÀ´?æ´¢??bitmap??Ï¢????Ò»??64?Ö½?objÊµ????Ö»????8?Ö½Ú£?????56?Ö½?Î´??
               */
            s = 1 << shift;//s??Ê¾Ã¿??slot???Ä´?Ð¡,?Ö½?Îª??Î»  
            n = (1 << (ngx_pagesize_shift - shift)) / 8 / s;  //????bitmap??Òª???Ù¸?slot obj??  
        
            if (n == 0) {
                n = 1; //??????ÒªÒ»??4MÒ³????Ð¡??Ò»??obj(2<<shift?Ö½?)À´?æ´¢bitmap??Ï¢
            }

            //???Ã¶?Ó¦??slot????map,???Ú´???map??slot????Îª1,??Ê¾??Ê¹?Ã²??????Ãµ?Ò»?????Ãµ?slot??(???????Ú¼?Â¼map??slot??)
            //????Îª1,??Îª???Î¼???Ê¹??.
            bitmap[0] = (2 << n) - 1; //?????Ç»?È¡??Ò³?ÄµÚ¶???obj????Îª??Ò»???Ñ¾?????bitmap?Ë£????Ôµ?Ò»???ÍµÚ¶???????????Ê¾???Ã£?bitmap[0]=3

            //????????obj??Î»Í¼??Òª???Ù¸?uintptr_t?æ´¢??????Ã¿??obj??Ð¡Îª64?Ö½Ú£???4K??????64??obj??Ò²????Òª8?Ö½Ú£?Á½??bitmap
            map = (1 << (ngx_pagesize_shift - shift)) / (sizeof(uintptr_t) * 8);

            for (i = 1; i < map; i++) {
                bitmap[i] = 0; //?ÓµÚ¶???bitmap??Ê¼??????Î»????0
            }

            page->slab = shift; //??Ò³??Ò»??obj??Ó¦???Ö½???Î»????Ð¡
            /* ngx_slab_pool_t + 9 * sizeof(ngx_slab_page_t)(slots_m[]) + pages * sizeof(ngx_slab_page_t)(pages_m[]) +pages*ngx_pagesize */
            page->next = &slots[slot];//Ö¸????????slots_m[i],????obj??Ð¡64?Ö½Ú£???Ö¸??slots[2]   slots[0-8] -----8-2048
            page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_SMALL; //???Ç¸?Ò³?Ð´æ´¢????Ð¡??128??obj

            slots[slot].next = page;

            p = ((page - pool->pages) << ngx_pagesize_shift) + s * n;
            //???Ø¶?Ó¦??Ö·.  ????Îª64?Ö½?obj???ò·µ»Øµ?startÎª?Ú¶?????Ê¼??obj???Â´Î·????ÓµÚ¶?????Ê¼??È¡??Ö·?Õ¼?obj
            p += (uintptr_t) pool->start;//???Ø¶?Ó¦??Ö·.,

            goto done;

        } else if (shift == ngx_slab_exact_shift) {

            page->slab = 1;//slab????Îª1   page->slab?æ´¢obj??bitmap,????????Îª1????Ê¾Ëµ??Ò»??obj??????È¥?? 4K??32??128?Ö½?obj,????Ò»??slabÎ»Í¼?ÕºÃ¿??Ô±?Ê¾??32??obj
            page->next = &slots[slot];
            //??Ö¸???Äº?Á½Î»??????,??NGX_SLAB_SMALL??Ê¾slot??Ð¡??ngx_slab_exact_shift  
            /*
                ????slab?Ä¸?16Î»(32Î»ÏµÍ³)????solt??Ó¦??map,???Ò¸Ã¶?Ó¦Îªmap?Äµ?Î»??Ó¦page?Ð¸?Î»??slot??.slab?Äµ?16Îª?æ´¢slot????Ð¡??Î»??.
               */ 
            page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_EXACT; 

            slots[slot].next = page;

            p = (page - pool->pages) << ngx_pagesize_shift;
            p += (uintptr_t) pool->start;//???Ø¶?Ó¦??Ö·.  

            goto done;

        } else { /* shift > ngx_slab_exact_shift */

            //????128??Ò²????????256?,4K????Ò²??16??256??????Ö»??Òªslab?Ä¸?16Î»??Ê¾objÎ»Í¼????
            page->slab = ((uintptr_t) 1 << NGX_SLAB_MAP_SHIFT) | shift;
            page->next = &slots[slot];
            //??Ö¸???Äº?Á½Î»??????,??NGX_SLAB_BIG??Ê¾slot??????ngx_slab_exact_shift  
            page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_BIG;

            slots[slot].next = page;

            p = (page - pool->pages) << ngx_pagesize_shift;
            p += (uintptr_t) pool->start;

            goto done;
        }
    }

    p = 0;

done:

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0, "slab alloc: %p", p);

    return (void *) p;
}


void *
ngx_slab_calloc(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    ngx_shmtx_lock(&pool->mutex);

    p = ngx_slab_calloc_locked(pool, size);

    ngx_shmtx_unlock(&pool->mutex);

    return p;
}


void *
ngx_slab_calloc_locked(ngx_slab_pool_t *pool, size_t size)
{
    void  *p;

    p = ngx_slab_alloc_locked(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}


void
ngx_slab_free(ngx_slab_pool_t *pool, void *p)
{
    ngx_shmtx_lock(&pool->mutex);

    ngx_slab_free_locked(pool, p);

    ngx_shmtx_unlock(&pool->mutex);
}

/*
???Ý¸?????Ö¸??p,?Í·???Ó¦?Ú´???.
1.?Òµ?p??Ó¦???Ú´????Í¶?Ó¦??m_page????Ôª??,
2.????m_page????Ôª?Øµ?preÖ¸??È·??Ò³??????
     (1).????NGX_SLAB_SMALL????,??sizeÐ¡??ngx_slab_exact_size
a.??????Ó¦slot??Îª????
b.??????????Ò³?æ¶¼????,????Ò³??????free??
    (2).????NGX_SLAB_EXACT????,??size????ngx_slab_exact_size
a.??????Ó¦slot??Îª????
b.??????????Ò³?æ¶¼????,????Ò³??????free??
    (3).????NGX_SLAB_BIG????,??size????ngx_slab_exact_size
a.??????Ó¦slot??Îª????
b.??????????Ò³?æ¶¼????,????Ò³??????free??
     (4).????NGX_SLAB_PAGE????,??size??Ð¡???Úµ???Ò»??Ò³??
a.??????Ó¦Ò³????Îª????
b.??Ò³??????free??
*/
void
ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)
{
    size_t            size;
    uintptr_t         slab, m, *bitmap;
    ngx_uint_t        n, type, slot, shift, map;
    ngx_slab_page_t  *slots, *page;

    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle->log, 0, "slab free: %p", p);

    if ((u_char *) p < pool->start || (u_char *) p > pool->end) {
        ngx_slab_error(pool, NGX_LOG_ALERT, "ngx_slab_free(): outside of pool");
        goto fail;
    }

    //????p?Òµ???Òª?Í·Åµ?m_pageÔª??  
    n = ((u_char *) p - pool->start) >> ngx_pagesize_shift;
    page = &pool->pages[n];
    slab = page->slab; //??????????Ê±??Ò»???Ô·???????page??????Ò»??page??slabÖ¸??????Ò»???Ô·????Ë¶??Ù¸?Ò³page
    //??pre?Äµ?Á½Î»À´?Ð¶Ï¸?Ò³???Ðµ?slot??Ð¡??ngx_slab_exact_size?Ä´?Ð¡??Ïµ  
    type = page->prev & NGX_SLAB_PAGE_MASK;

    switch (type) {

    case NGX_SLAB_SMALL://slotÐ¡??ngx_slab_exact_size  

        //??obj??Ð¡??Æ«??  
        shift = slab & NGX_SLAB_SHIFT_MASK;
        size = 1 << shift;//??????obj?Ä´?Ð¡  

        if ((uintptr_t) p & (size - 1)) {//???Ú¶???,p?Äµ?Ö·Ò»????obj??Ð¡????????  
            goto wrong_chunk;
        }

        n = ((uintptr_t) p & (ngx_pagesize - 1)) >> shift;//????p??Ó¦??obj????Î»??  
        m = (uintptr_t) 1 << (n & (sizeof(uintptr_t) * 8 - 1));////??????uintptr_t??,p??Æ«??,????????uintptr_t?ÐµÄµÚ¼?Î»  
        //????map?Ç¸???uintptr_t???Öµ?,?????????Ã¿???Ó¦??uintptr_t??Æ«??,???????Ú¼???uintptr_t  
        n /= (sizeof(uintptr_t) * 8); //??obj???Úµ????Ç¸?bitmap??????Ò»??Ò³64??obj??????Òª2??bitmap??Ê¾??64??obj??Î»Í¼
        bitmap = (uintptr_t *)
                             ((uintptr_t) p & ~((uintptr_t) ngx_pagesize - 1));//????p??Ó¦??pageÒ³????Î»Í¼??Î»??  

        if (bitmap[n] & m) {//??????mÎ»È·ÊµÎª1,  

            if (page->next == NULL) { //????Ò³???Äµ?Ç°×´Ì¬??È«????Ê¹??,?Í°???Á´??slot_m[]??
                slots = (ngx_slab_page_t *)
                                   ((u_char *) pool + sizeof(ngx_slab_pool_t));//??Î»slot_m????  

                //?Òµ???Ó¦??slot_m[]??Ôª??  
                slot = shift - pool->min_shift;

                //Á´????Ó¦??slot[]?Ð£???Ê¾??Ò³???Ô¼???Ê¹???Ë£???ngx_slab_calloc_locked?Ö¿??Ô±???????Ò³?????Ð·???obj
                page->next = slots[slot].next;
                slots[slot].next = page;

                //????m_page??pre  
                page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_SMALL;
                page->next->prev = (uintptr_t) page | NGX_SLAB_SMALL;
            }

             //Ò³???Äµ?Ç°×´Ì¬?Ç²?????Ê¹??,???Ñ¾???slot??  ????slot??Ó¦Î»??Îª????,??0  
            bitmap[n] &= ~m;

            //?????Ä²?????Òª?Ç²é¿´????Ò³???Ç·???Ã»??, ??????Ã»Ê¹??,????Ò³??????free??  
            
            n = (1 << (ngx_pagesize_shift - shift)) / 8 / (1 << shift);

            if (n == 0) {//??????Òª???Ù¸?4?Ö½?bitmapÀ´?æ´¢Î»Í¼??????64??obj??Òª2??bitmapÀ´??Ê¾64Î»,??Òª???Ù¸?objÀ´?æ´¢??Á½??bitmap??Ò»????Ò»??obj???æ´¢Á½??bitmap??Ò²??????64?Ö½??Ðµ?8?Ö½?
                n = 1;
            }

            //?é¿´??Ò»??uintptr_t?ÐµÄ¿?obj?Ç·ñ¶¼¿???  
            if (bitmap[0] & ~(((uintptr_t) 1 << n) - 1)) {
                goto done;
            }

             //????Î»Í¼Ê¹???Ë¶??Ù¸?uintptr_tÀ´?æ´¢
            map = (1 << (ngx_pagesize_shift - shift)) / (sizeof(uintptr_t) * 8);

            for (n = 1; n < map; n++) {//?é¿´????uintptr_t?Ç·???Ã»Ê¹??  
                if (bitmap[n]) {
                    goto done;
                }
            }

            ngx_slab_free_pages(pool, page, 1); //????Ò³?æ¶¼Ã»??Ê¹?Ã£??é»¹??free 

            goto done;
        }

        goto chunk_already_free;

    case NGX_SLAB_EXACT:
        //p????Ó¦????slab(objÎ»Í¼)?Ðµ?Î»??.  
        m = (uintptr_t) 1 <<
                (((uintptr_t) p & (ngx_pagesize - 1)) >> ngx_slab_exact_shift);
        size = ngx_slab_exact_size;

        if ((uintptr_t) p & (size - 1)) {//????pÎªpage?Ðµ?obj??,??Ã´Ò»????size??????  
            goto wrong_chunk;
        }

        if (slab & m) {//slab(Î»Í¼)?Ð¶?Ó¦??Î»Îª1  
            if (slab == NGX_SLAB_BUSY) {//????????Ò³???Ðµ?????obj?é¶¼??Ê¹??,????Ò³page[]??slot[]Ã»?Ð¶?Ó¦??Ïµ,??????Òª??Ò³page[]??slot[]??Ó¦??Ïµ????
                 //??Î»slot[]????  
                slots = (ngx_slab_page_t *)
                                   ((u_char *) pool + sizeof(ngx_slab_pool_t));
                slot = ngx_slab_exact_shift - pool->min_shift;//??????Ò³??ÒªÁ´??slot[]???Ä¸?????  

                //????page[]Ôª?Øº?slot[]?Ä¶?Ó¦??Ïµ??Í¨??prev??nextÖ¸??
                page->next = slots[slot].next;
                slots[slot].next = page;
                
                page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_EXACT;
                page->next->prev = (uintptr_t) page | NGX_SLAB_EXACT;
            }

            page->slab &= ~m;//??slab????Ó¦Î»??????Îª0  

            if (page->slab) {//pageÒ³???Ð»???????Ê¹?Ãµ?obj??,??ÎªslabÎ»Í¼??Îª0
                goto done;
            }

            ngx_slab_free_pages(pool, page, 1);//pageÒ³????????slab?é¶¼Ã»??Ê¹??  

            goto done;
        }

        goto chunk_already_free;

    case NGX_SLAB_BIG://?Ã»??????Ú´??Ä´?Ð¡????ngx_slab_exact_size  
        //slab?Ä¸?16Î»??slot????Î»Í¼,??16Î»???Ú´æ´¢slot????Ð¡??Æ«??  

        shift = slab & NGX_SLAB_SHIFT_MASK;
        size = 1 << shift;

        if ((uintptr_t) p & (size - 1)) {
            goto wrong_chunk;
        }
        //?Òµ???slab????Î»Í¼?Ðµ?Î»??.????Òª×¢??Ò»??,  
        //Î»Í¼?æ´¢??slab?Ä¸?16Î»,????Òª+16(??+ NGX_SLAB_MAP_SHIFT)  
        m = (uintptr_t) 1 << ((((uintptr_t) p & (ngx_pagesize - 1)) >> shift)
                              + NGX_SLAB_MAP_SHIFT);

        if (slab & m) {//??slab??È·Êµ???Ú±?Ê¹??  

            if (page->next == NULL) {//????????Ò³???Ðµ?????obj?é¶¼??Ê¹??,????Ò³page[]??slot[]Ã»?Ð¶?Ó¦??Ïµ,??????Òª??Ò³page[]??slot[]??Ó¦??Ïµ????
                //??Î»slot[]????  
                slots = (ngx_slab_page_t *)
                                   ((u_char *) pool + sizeof(ngx_slab_pool_t));
                slot = shift - pool->min_shift;
                //?Òµ?slot[]?????Ð¶?Ó¦??Î»??,????slot[]??page[]?Ä¶?Ó¦??Ïµ
                page->next = slots[slot].next;
                slots[slot].next = page;

                page->prev = (uintptr_t) &slots[slot] | NGX_SLAB_BIG;
                page->next->prev = (uintptr_t) page | NGX_SLAB_BIG;
            }

            page->slab &= ~m;//????slab????Ó¦??Î»Í¼Î»??Îª0,??????  
            
            //????slabÒ³????slot?é»¹?Ú±?Ê¹??  
            if (page->slab & NGX_SLAB_MAP_MASK) {
                goto done;
            }

            //????pageÒ³??????slab?é¶¼????Ê¹?Ã¾Í½???Ò³??Á´??free??  
            ngx_slab_free_pages(pool, page, 1);

            goto done;
        }

        goto chunk_already_free;

    case NGX_SLAB_PAGE://?Ã»??é»¹????Ò³??  

        if ((uintptr_t) p & (ngx_pagesize - 1)) { //p??Ò²?????Ä£???????
            goto wrong_chunk;
        }

        if (slab == NGX_SLAB_PAGE_FREE) { 
        
            ngx_slab_error(pool, NGX_LOG_ALERT,
                           "ngx_slab_free(): page is already free");
            goto fail;
        }

        if (slab == NGX_SLAB_PAGE_BUSY) {
        //Ëµ????Á¬??????????page?Ä·??×¸?page??????Ö±???Í·Å£??????â¼¸??pageÒ»???Í·Å£?????pÖ¸??Ö¸??????????page
            ngx_slab_error(pool, NGX_LOG_ALERT,
                           "ngx_slab_free(): pointer to wrong page");
            goto fail;
        }

        //????Ò³????Ó¦??page[]??  
        n = ((u_char *) p - pool->start) >> ngx_pagesize_shift;
        size = slab & ~NGX_SLAB_PAGE_START;//?????é»¹page?Ä¸???  

        ngx_slab_free_pages(pool, &pool->pages[n], size); //?é»¹Ò³??  

        ngx_slab_junk(p, size << ngx_pagesize_shift);

        return;
    }

    /* not reached */

    return;

done:

    ngx_slab_junk(p, size);

    return;

wrong_chunk:

    ngx_slab_error(pool, NGX_LOG_ALERT,
                   "ngx_slab_free(): pointer to wrong chunk");

    goto fail;

chunk_already_free:

    ngx_slab_error(pool, NGX_LOG_ALERT,
                   "ngx_slab_free(): chunk is already free");

fail:

    return;
}

/*
????Ò»??slab page??????slab pageÖ®???á±»??À´È·???????????Ä¿Õ¼????Ú´æ»º????Î»?? 

?????Ü¹???6??page[]??ngx_slab_init??page[0]??next??prev??Ö¸??free??free??nextÒ²Ö¸??page[0]????????ngx_slab_alloc_pages????È¡3??pages??Ê±??
??Ç°????pages(page[0], page[1], page[2])?á±»?????Ã£???Ä©Î²page[5]??prevÖ¸??page[3],????page[3]??slabÖ¸??????Ö»??6-3=3??page???Ô·????Ë£?
È»??page[3]??next??prevÖ¸??free,free??next??prevÒ²Ö¸??page[3]??Ò²?????Â´?Ö»?Ü´?page[3]??Ê¼??È¡Ò³

*/ //????Ò»??Ò³??,????Ò³????free??Õª??.

/* 
-------------------------------------------------------------------
| page1  | page2 | page3 | page4| page5) | page6 | page7 | page8 |
--------------------------------------------------------------------
??Ê¼×´Ì¬: pool->freeÖ¸??page1,page1Ö¸??poll->free,??????page??next??prevÄ¬??Ö¸??NULL,Ò²????pool->freeÖ¸??????page?å£¬page1->slab=8

1.??????Ò»??ngx_slab_alloc_pages??È¡Á½??page????page1??page2????????È¥??page1Îª??Á½??page????page1->slabÖ»????Á½??Á¬??page??Ò»????????,
    page2->slab = NGX_SLAB_PAGE_BUSY;??Ê¾???Ç¸???page1Ò»????????È¥?Ä£????Ò±?page??????page????Ê±??pool->freeÖ¸??page3,????Ê¾page3->slab=6??
    ??Ê¾page3??Ê¼????6??page????Ê¹??
2.?????Ú¶????Ö»?È¡??3??page(page3-5),??page3????page,page3->slab=3,Í¬Ê±page4,page5->slab = NGX_SLAB_PAGE_BUSY;??Ê¾???Ç¸???page1Ò»
    ????????È¥?Ä£????Ò±?page??????page????Ê±??pool->freeÖ¸??page6,????Ê¾page6->slab=3????Ê¾page6??Ê¼????3??page????Ê¹??
3. Í¬???Ù»?È¡1??page,page6????Ê±??pool->freeÖ¸??page7,????Ê¾page7->slab=2????Ê¾page7??Ê¼????2??page????Ê¹??
4. ?????Í·Åµ?1??page1??Ê¼??2??page??????ngx_slab_free_pages?Ð»??Ñµ?3????Ê£????Á½??Î´??????page7(Êµ?????Ç°?page7??Ê¼??2??page??Ê¶Îª1????page)
   ??page1(page1Êµ??????Ê±????Ê¶???Çµ?Ò»???Ðµ?page1??Ê¼??2??page)??pool->free?Î³?Ò»??Ë«??Á´?í»·?????Ô¼?
  
                      pool->free  
                    ----------  /                 
 -----------------\|         | --------------------------------------  
|  ----------------|         | -----------------------------------   |
|  |                 -----------                                  |  |
|  |                                                              |  |
|  |     page1 2                                   page7 2        |  |
|  |  \ ----------                          \  -----------   /    |  |
|   --- |    |    |----------------------------|    |     | -------  | 
------- |    |    |--------------------------- |    |     | ---------- 
        ----------  \                           ---------

5.???Í·?ngx_slab_free_pagespage3??Ê¼??3??pageÒ³????page3Ò²??Á¬?Óµ?Ë«?ò»·±??Ð£?Á´??pool->free??page1[i]Ö®?ä£¬×¢????Ê±????page1??page2?Ç½???Ò»????page
  ??Ã»?Ð¶????Ç½??ÐºÏ²???page1->slab????=2  page2->slab????=3????Ã»?Ð°????ÇºÏ²?ÎªÒ»??????page->slab=5,?????Â´???allocÒ»??4page?Ä¿Õ¼ä£¬??
  ???ä²»?É¹???
*/
static ngx_slab_page_t *
ngx_slab_alloc_pages(ngx_slab_pool_t *pool, ngx_uint_t pages) //??ngx_slab_free_pages?????Ä¶?????
{
    ngx_slab_page_t  *page, *p;

    //??Ê¼????Ê±??pool->free.nextÄ¬??Ö¸????Ò»??pool->pages
    //??pool->free.next??Ê¼??Ã¿??È¡(slab page) page = page->next  
    for (page = pool->free.next; page != &pool->free; page = page->next) { //????Ò»??????pageÒ³??Ã»?Ð£??Í²???????Ñ­????

    /*
    ????slab pageÊ£?ÂµÄ»???Ò³??Ä¿>=??Òª?????Ä»???Ò³??Ä¿pages?????Ô·??ä£¬????????????free,Ö±????Ò»????page??????Á¬??page???Í´??Úµ?????Òª??????pages?????Å¿??Ô·??? 
    slab???×´Î·???page??Ê¼??slab??Ò³??Ê±??Ö¸???Ä£????Í·Åµ?Ê±??slab?????×´Î·???Ê±????slab???????ä£¬Ò²????Ëµ?Í·?page?ó²»»??????Úµ?Á½??pageÒ³??slab???Ï²???
    ?????×´Î¿???page1??Ê¼??3??pageÒ³?Õ¼ä£¬page1->slab=3,?????Å¿???page2??Ê¼??2??pageÒ³?Õ¼ä£¬page2->slab=2,??Á¬???Í·?page1??page2??Ó¦?Ä¿Õ¼????????Ç»???
    Á½????Á¢??page[]?Õ¼ä£¬slab?Ö±???2??3,??????????Á½??Á¬???Õ¼????ÐºÏ²?Îª1??(Ò²?????Âµ?page3,page3?×µ?Ö·????page2??????page3->slab=3+2=5)
    */
        if (page->slab >= pages) {

            //?????Ü¹???6??page[]??ngx_slab_init??page[0]??next??prev??Ö¸??free??free??nextÒ²Ö¸??page[0]????????ngx_slab_alloc_pages????È¡3??pages??Ê±??
            //??Ç°????pages(page[0], page[1], page[2])?á±»?????Ã£???Ä©Î²page[5]??prevÖ¸??page[3],????page[3]??slabÖ¸??????Ö»??6-3=3??page???Ô·????Ë£?
            //È»??page[3]??next??prevÖ¸??free,free??next??prevÒ²Ö¸??page[3]??Ò²?????Â´?Ö»?Ü´?page[3]??Ê¼??È¡Ò³
            if (page->slab > pages) {  
                page[page->slab - 1].prev = (uintptr_t) &page[pages];

                //???Â´Ó±???slab page??Ê¼???Âµ?pages??slab page?Ä»???Ò³??Ä¿Îª????slab page??Ä¿??È¥pages  
                //???Â´Î¿??Ô´?page[pages]??Ê¼??????Ò³??next??prevÖ¸??pool->free,Ö»ÒªÒ³??next??prevÖ¸????free??????Ê¾???Ô´Ó¸?Ò³??Ê¼????Ò³page
                page[pages].slab = page->slab - pages; //?Â´Î¿?Ê¼??????page[]????Ê¼??È¡Ò³?????????Ú¿???pageÖ»??page->slab - pages????
                page[pages].next = page->next; //?Ã¿???Ò³??nextÖ¸??pool->free.next
                page[pages].prev = page->prev; //?Ã¿???Ò³??prevÖ¸??pool->free.next

                p = (ngx_slab_page_t *) page->prev;
                p->next = &page[pages];//????pool->free.next = &page[pages]???Â´Î´Óµ?pages??slab page??Ê¼??????????for()Ñ­??????
                page->next->prev = (uintptr_t) &page[pages]; //poll->free->prev = &page[pages]Ö¸???Â´Î¿??Ô·???Ò³??Ò³??Ö·

            } else { //pageÒ³???????Ë£???free??next??prev??Ö¸???Ô¼????????Â´??Ù½????Ãº???????for()Ñ­????Ê±???Þ·?????Ñ­?????Ð£?Ò²???ä²»??page
                //????freeÖ¸????pageÒ³????Ò³??Ð¡Îª2?????Ãº???Òª????È¡3??Ò³????Ö±?Ó°???Á½??Ò³???Ø³?È¥??????Ëµ??Á½??Ò³???????????Å£??Ü±?Ã»?ÐºÃ¡?
                p = (ngx_slab_page_t *) page->prev; //??È¡poll->free
                p->next = page->next; //poll->free->next = poll->free
                page->next->prev = page->prev; ////poll->free->prev = poll->free   free??next??prev??Ö¸?????Ô¼???Ëµ??Ã»?Ð¶????Õ¼???????
            }

            //NGX_SLAB_PAGE_START????page?Ç·?????pages??Ò³?Äµ?Ò»??Ò³?????Úµ?Ò»??Ò³page?Ð¼?Â¼??????Á¬????pages??Ò³??Ò»????????
            page->slab = pages | NGX_SLAB_PAGE_START; //???Â±???????page slab?ÐµÄµ?Ò»????slab??Ô±????Ò³?Ä¸?????Õ¼??????  
            //page??next??prev???àµ±??Ö¸????NULL?Ë£?
            page->next = NULL; 
            page->prev = NGX_SLAB_PAGE; //pageÒ³?æ²»????slotÊ±??,????????Ò³?????????Ã»?,pre?Äº?Á½Î»ÎªNGX_SLAB_PAGE

            if (--pages == 0) { //pagesÎª1????Ö±?Ó·??Ø¸?page
                return page;
            }

            for (p = page + 1; pages; pages--) {
                //??????????Ò³??pages>1?????Âº???page slab??slab??Ô±ÎªNGX_SLAB_PAGE_BUSY  
                p->slab = NGX_SLAB_PAGE_BUSY; 
                //????????Á¬??????????page???????Ò²?????page??????Ò»?Î·???3??page,??????pageÎª[1-3]????page[1].slab=3  page[2].slab=page[3].slab=NGX_SLAB_PAGE_BUSY??Â¼
                p->next = NULL;
                p->prev = NGX_SLAB_PAGE;
                p++;
            }

            return page;
        }
    }

    if (pool->log_nomem) {
        ngx_slab_error(pool, NGX_LOG_CRIT,
                       "ngx_slab_alloc() failed: no memory");
    }

    //Ã»???Òµ???????Ò³  
    return NULL;
}

//?Í·?pageÒ³??Ê¼??pages??Ò³??
static void
ngx_slab_free_pages(ngx_slab_pool_t *pool, ngx_slab_page_t *page,
    ngx_uint_t pages) //?Í·?pages??Ò³??,????Ò³??????free??
{
    ngx_uint_t        type;
    ngx_slab_page_t  *prev, *join;

    page->slab = pages--; //?Í·Åµ?pagesÒ³??-1??????Òª?????

    if (pages) {
        ngx_memzero(&page[1], pages * sizeof(ngx_slab_page_t)); //????Ò»???Ô·????Ë´??Úµ???2??page??????Òª????page????????page?Ö¸???0????
    }

    if (page->next) { 
        //????slot[]??page[]?Ä¹?Áª????slot[]??next??prevÖ¸??slot[]????
        prev = (ngx_slab_page_t *) (page->prev & ~NGX_SLAB_PAGE_MASK);
        prev->next = page->next;
        page->next->prev = page->prev;
    }
    
    //????Òª?Í·Åµ?Ò³pages??????Ò»??page???Ð¿???Ò»???Í·?3??Ò³????join??????????Ò³????Ê¼??Ö·,????pagesÎª1????joinÖ±??Ö¸????????page
    join = page + page->slab; 

    if (join < pool->last) { //join????pool??????Ò»??page 
        type = join->prev & NGX_SLAB_PAGE_MASK;
        
        if (type == NGX_SLAB_PAGE) {//??ngx_slab_alloc_pages?????Ä¶Á£?
            
            if (join->next != NULL) { //??ifÓ¦??Ê¼?????ã²»?????/  ??alloc??Ê±????Ò³page??next??Ö¸??NULL
                pages += join->slab;
                page->slab += join->slab;

                prev = (ngx_slab_page_t *) (join->prev & ~NGX_SLAB_PAGE_MASK);
                prev->next = join->next;
                join->next->prev = join->prev;

                join->slab = NGX_SLAB_PAGE_FREE;
                join->next = NULL;
                join->prev = NGX_SLAB_PAGE;
            }
        }
    }

    if (page > pool->pages) {
        join = page - 1;
        type = join->prev & NGX_SLAB_PAGE_MASK;

        if (type == NGX_SLAB_PAGE) {

            if (join->slab == NGX_SLAB_PAGE_FREE) {
                join = (ngx_slab_page_t *) (join->prev & ~NGX_SLAB_PAGE_MASK);
            }

            if (join->next != NULL) {
                pages += join->slab;
                join->slab += page->slab;

                prev = (ngx_slab_page_t *) (join->prev & ~NGX_SLAB_PAGE_MASK);
                prev->next = join->next;
                join->next->prev = join->prev;

                page->slab = NGX_SLAB_PAGE_FREE;
                page->next = NULL;
                page->prev = NGX_SLAB_PAGE;

                page = join;
            }
        }
    }

    if (pages) { //????Ò»??alloc 3??page????????page[3 4 5],??page[5]??prevÖ¸??page[3]
        page[pages].prev = (uintptr_t) page;
    }

    /*
    freepage[i]Îª?????Í·Åµ?freepage[i]??Ê¼??pages??pageÒ³
    unusepage[i]Îª??Î´????Ê¹?Ãµ?Ô­Ê¼pageÒ³??Ê¼???????Ü»??Ð¶???page[]??????????
                          pool->free  
                        ----------  /                 
     -----------------\|         | --------------------------------------  
    |  ----------------|         | -----------------------------------   |
    |  |                 -----------                                  |  |
    |  |                                                              |  |
    |  |     freepage[i]                           unusepage[i]       |  |
    |  |  \ ----------                          \  -----------   /    |  |
    |   --- |    |    |----------------------------|    |     | -------  | 
    ------- |    |    |--------------------------- |    |     | ---------- 
            ----------  \                           ---------

    ?ßµ?????????pool->freeÖ¸???Ë¸??Í·Åµ?page[]??×¢????Ê±????page->slab????

   
     */
    

    //??ngx_slab_alloc_pages?????Ä¶Á£? ?????Í·Åº??Í»???Ö®Ç°freeÖ¸???Ä¿???pageÒ³???Í·Åµ?pageÒ³?Ô¼?pool->free?Î³?Ò»??????Á´??
    page->prev = (uintptr_t) &pool->free;
    page->next = pool->free.next;

    page->next->prev = (uintptr_t) page;

    pool->free.next = page;
}


static void
ngx_slab_error(ngx_slab_pool_t *pool, ngx_uint_t level, char *text)
{
    ngx_log_error(level, ngx_cycle->log, 0, "%s%s", text, pool->log_ctx);
}
